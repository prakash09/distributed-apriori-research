diff --git a/apriori.py b/apriori.py
index 43ce5fc..28e070f 100644
--- a/apriori.py
+++ b/apriori.py
@@ -6,86 +6,23 @@ Usage:
 
     $python apriori.py -f DATASET.csv -s 0.15 -c 0.6
 """
-import struct
 import socket
 import json
 import sys
-import pdb
+#import pdb
 from itertools import chain, combinations
 from collections import defaultdict
 from optparse import OptionParser
 import time
 
-def timing(f):
-    def wrap(*args):
-        time1 = time.time()
-        ret = f(*args)
-        time2 = time.time()
-        print '%s function took %0.3f ms' % (f.func_name, (time2-time1)*1000.0)
-        return ret
-    return wrap
-largeSet = dict()
-@timing
-def starResove(x, largeSet, k):
-	#print " I am inside star resolve"
-        j=k-1
-        temp=1
-        c=0
-        while True:
-	    #pdb.set_trace()
-	    subset=set(combinations(x,j))
-               
-            for y in subset:
-                y=frozenset(list(y))
-                if (y in largeSet[j]):
-                        c=c+1
-                        if largeSet[j][y]< temp:
-                                    temp=largeSet[j][y]
-            if(c>1):
-                break
-            elif(c==1):
-                j=k-j
-                #subset.clear()
-            else:
-                #subset.clear()
-                j=j-1
-
-
-	#if( temp==1):
-        #	return 0
-    	#else:
-        return temp
-def send_msg(sock, msg):
-    # Prefix each message with a 4-byte length (network byte order)
-    msg = struct.pack('>I', len(msg)) + msg
-    sock.sendall(msg)
-
-def recv_msg(sock):
-    # Read message length and unpack it into an integer
-    raw_msglen = recvall(sock, 4)
-    if not raw_msglen:
-        return None
-    msglen = struct.unpack('>I', raw_msglen)[0]
-    # Read the message data
-    return recvall(sock, msglen)
-
-def recvall(sock, n):
-    # Helper function to recv n bytes or return None if EOF is hit
-    data = ''
-    while len(data) < n:
-        packet = sock.recv(n - len(data))
-        if not packet:
-            return None
-        data += packet
-    return data
 def subsets(arr):
-    #print "I am inside subsets"
+    print "I am inside subsets"
     """ Returns non empty subsets of arr"""
     return chain(*[combinations(arr, i + 1) for i, a in enumerate(arr)])
 
-@timing
+
 def returnItemsWithMinSupport(itemSet, transactionList, minSupport, freqSet,k):
-	#print "I am inside returnItemsWithMinSupport"
+	print "I am inside returnItemsWithMinSupport"
         """calculates the support for items in the itemSet and returns a subset
        of the itemSet each of whose elements satisfies the minimum support"""
         _itemSet = {}
@@ -99,18 +36,23 @@ def returnItemsWithMinSupport(itemSet, transactionList, minSupport, freqSet,k):
 
         for item, count in localSet.items():
                 support = float(count)/len(transactionList)
-		_itemSet[item]=support
+		if k==1 :
+			_itemSet[item]=support
+		else:
+                	if support >= minSupport:
+                        	_itemSet[item]=support
+
         return _itemSet
 
 
 def joinSet(itemSet, length):
-	#print "I am inside joinSet"
+	print "I am inside joinSet"
         """Join a set with itself and returns the n-element itemsets"""
         return set([i.union(j) for i in itemSet for j in itemSet if len(i.union(j)) == length])
 
 
 def getItemSetTransactionList(data_iterator):
-    #print "I am inside getItemSetTransactionList"
+    print "I am inside getItemSetTransactionList"
     transactionList = list()
     itemSet = set()
     for record in data_iterator: #yield object data_iterator
@@ -131,118 +73,69 @@ def runApriori(data_iter, minSupport, minConfidence): #first line in splitted
      - items (tuple, support)
      - rules ((pretuple, posttuple), confidence)
     """
-    #print "i am inside runApriori"
+    print "i am inside runApriori"
     itemSet, transactionList = getItemSetTransactionList(data_iter)
 
     freqSet = defaultdict(int)
-
+    largeSet = dict()
     # Global dictionary which stores (key=n-itemSets,value=support)
     # which satisfy minSupport
 
-    #assocRules = dict()
+    assocRules = dict()
     # Dictionary which stores Association Rules
     k=1
     oneCSet = returnItemsWithMinSupport(itemSet,
                                         transactionList,
                                         minSupport,
                                         freqSet,k)
-    largeSet[k] = oneCSet#largeSet is a dictionary of dictionary containing key value pairs
-    print "joined 1-itemset with frequency are=",len(oneCSet)
     oneLFS=set()
     for x in oneCSet.keys():
 		if(oneCSet[x]>=minSupport):
-			oneLFS.add(x)#oneLFS contains local 1-frequent itemsets without support value
-   # print "My Local 1-frequent itemsets are=\n",oneLFS,len(oneLFS)
+			oneLFS.add(x)
     clientsocket= socket.socket(socket.AF_INET, socket.SOCK_STREAM)
     clientsocket.connect(('10.0.0.21', 8089))
+
     oneCSet=json.dumps(str(oneCSet))
-    send_msg(clientsocket, oneCSet)#sending oneCSet i.e. all one itemsets with their support to polling site
-    data=recv_msg(clientsocket)#receiving global 1-frequent itemsets
-    if data:
-    	data=json.loads(data)
-    	data=eval(data)
-    	print "received global 1-frequent itemsets:\n",data,len(data)
+    clientsocket.sendall(str(oneCSet))
+    data=clientsocket.recv(10000)
+    data=json.loads(data)
+    data=eval(data)
+
     clientsocket.close()
     oneGFS=set()
     for x in data.keys():
-		oneGFS.add(x)#extracting key of global received data
-    print "length of data received should match with above len\n",len(oneGFS)
-    currentLSet=set.intersection(oneGFS, oneLFS)#intersecting local and global itemsets for joining
-    print "After intersecting local with global received",currentLSet,len(currentLSet)
+		oneGFS.add(x)
+    currentLSet=set.intersection(oneGFS, oneLFS)
     k = 2
-    PreScan=set()
-    while True:
-        currentLSet = joinSet(currentLSet, k)#currentLSet contains joined keys
-        print "joined keys are=", len(currentLSet),"Prescan are", len(PreScan)
-        currentCSet = returnItemsWithMinSupport(currentLSet,transactionList,minSupport,freqSet,k)
-        print "k-itemset with frequency are=\n",currentCSet,len(currentCSet)
-        prescan=returnItemsWithMinSupport(PreScan,transactionList,minSupport,freqSet,k)#
-#	print "Previous itemsets need to be scanned are=\n",prescan,len(prescan)
-        PreScan=currentLSet# new set which need to be differentiate
-        k_LFS={}
-        for x in currentCSet.keys():
-            if(currentCSet[x]>=minSupport):
-                k_LFS[x]=currentCSet[x]
-        #print "My Local k-frequent itemsets are=\n",k_LFS,len(k_LFS)
-	# add prescan with k_LFS to send it to server
-	k_LFS=dict(k_LFS.items()+prescan.items())#
-        clients= socket.socket(socket.AF_INET, socket.SOCK_STREAM)
-        clients.connect(('10.0.0.21', 8089))
-        oneCSet=json.dumps(str(k_LFS))
-       
-        send_msg(clients, oneCSet)
-        
-        data=recv_msg(clients)
-       	if data:
-    		data=json.loads(data)
-	    	data=eval(data)
-	    	print "star itemsets received are=",data,len(data)
-        #pdb.set_trace()
-                for x in data.keys():
-			try:
-				data[x]=currentCSet[x]
-            #if x in currentCSet:
-               # data[x]=currentCSet[x]
-            #else:
-			except KeyError:
-				data[x]=starResove(x,largeSet,k)
-	
-	        print "value of star itemsets calculated are=",data,len(data)
-        data=json.dumps(str(data))
-        udpsocket= socket.socket(socket.AF_INET, socket.SOCK_STREAM)
-        udpsocket.connect(('10.0.0.21',8090))
-        #udpsocket.sendto(str(data),('10.0.0.21',8090))
-        send_msg(udpsocket,data)
-        udpsocket.close()
-        data=recv_msg(clients)#global data received
+    while(currentLSet != set([])):
+        largeSet[k-1] = currentLSet
+        currentLSet = joinSet(currentLSet, k)
+        currentCSet = returnItemsWithMinSupport(currentLSet,
+                                                transactionList,
+                                                minSupport,
+                                                freqSet,k)
+        clientsocket= socket.socket(socket.AF_INET, socket.SOCK_STREAM)
+        clientsocket.connect(('10.0.0.21', 8089))
+
+        oneCSet=json.dumps(str(currentCSet))
+        clientsocket.sendall(str(oneCSet))
+            #time.sleep(2)
+        data=clientsocket.recv(10000)
+        data=json.loads(data)
+        data=eval(data)
+
+        clientsocket.close()
         k_GFS=set()
-	if data:
-    		data=json.loads(data)
-    		data=eval(data)
-    		print "received global k-frequent itemsets including star itemsets\n",data,len(data)
-                clients.close()
-                
-                for x in data.keys():
-        	    k_GFS.add(x)
-	PreScan= k_GFS.difference(PreScan) #take diffence of received globall set with already scanned data items
-#	print "extra needed to scan with k+1 itemsets=\n",PreScan,len(PreScan)
-        #if not k_LFS:
-         #   break
-        currentLSet = set([ x for x in k_LFS.keys()])
+        for x in data.keys():
+        	k_GFS.add(x)
+
+
+        currentLSet = set([ x for x in currentCSet.keys()])
         currentLSet=set.intersection(k_GFS, currentLSet)
-        print "After intersecting local with global received",currentLSet,len(currentLSet)
-        largeSet[k] = currentCSet
         k = k + 1
-        if (not currentLSet and not PreScan):
-            clients= socket.socket(socket.AF_INET, socket.SOCK_STREAM)
-            clients.connect(('10.0.0.21', 8089))
-            oneCSet=json.dumps(str(currentLSet))
-            send_msg(clients, oneCSet)
-            clients.close()
-            break
 
     def getSupport(item):
-    	    #print "I am inside getSupport function"
+    	    print "I am inside getSupport function"
             """local function which Returns the support of an item"""
             return float(freqSet[item])/len(transactionList)
 
@@ -258,18 +151,15 @@ def runApriori(data_iter, minSupport, minConfidence): #first line in splitted
             for element in _subsets:
                 remain = item.difference(element)
                 if len(remain) > 0:
-                    try:
-                        confidence = getSupport(item)/getSupport(element)
-                        if confidence >= minConfidence:
-                            toRetRules.append(((tuple(element), tuple(remain)),
-                                            confidence))
-                    except:
-                        continue
+                    confidence = getSupport(item)/getSupport(element)
+                    if confidence >= minConfidence:
+                        toRetRules.append(((tuple(element), tuple(remain)),
+                                           confidence))
     return toRetItems, toRetRules
 
 
 def printResults(items, rules):
-    #print "I am inside printResults function"
+    print "I am inside printResults function"
     """prints the generated itemsets and the confidence rules"""
     for item, support in items:
         print "item: %s , %.3f" % (str(item), support)
@@ -280,7 +170,7 @@ def printResults(items, rules):
 
 
 def dataFromFile(fname):
-	#print "I am inside dataFromFile"
+	print "I am inside dataFromFile"
         """Function which reads from the file and yields a generator"""
         file_iter = open(fname, 'rU')
         for line in file_iter:
